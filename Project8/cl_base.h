#ifndef CL_BASE_H //см. 5.7 методичку
#define CL_BASE_H
#include<vector>
#include<string>
class cl_base//см. п.8.3
{
protected:
	 /*props*/
	/*наименование объекта;*/
	std::string name;
	/*указатель на головной объект на дереве иерархии объектов;*/
	cl_base* head;
	/*перечень указателей на иерархически подчиненных объектов (объектов-потомков).*/
	std::vector<cl_base*> children;
	/*состояние объекта*/
	int state = 0;
	/*methods*/
public:
	/*конструктор объекта с параметром - указатель на головной объект*/
	cl_base(cl_base*);
	//конструктор по умолчанию
	cl_base();
	/*конструктор объекта с параметрами - имя объекта, указатель на головной объект*/
	cl_base(std::string, cl_base*);
	/*конструктор объекта с параметрами - имя объекта, указатель на головной объект ,состояние*/
	cl_base(std::string, cl_base*, int);
	/*получения имени объекта*/
	std::string  get_name();
	/*присвоения имени объекту*/
	void set_name(std::string);


	/*получения указателя на головной объект*/
	cl_base* const get_head();
	/*переопределения головного объекта*/
	void set_head(cl_base*);


	/*получения номера состояния объекта*/
	int const get_state();
	/*определения номера состояния объекта*/
	void set_state(int);


	/*класс принадлежности*/
	 int  get_class();
	//список потомков
	std::vector<cl_base*> get_children();
	/*добавление нового объекта потомка*/
	void add_child(cl_base* obj);
	/*получения указателя на объект потомок по имени объекта*/
	cl_base*  get_child(std::string);
	/*получения количества подчиненных объектов*/
	size_t const child_count();
	/*получения указателя на объект потомок по индексу в списке подчиненных объектов*/
	cl_base*  get_child(size_t);
	/*удаления объекта потомка (удалить все подчиненные объекты по иерархии)*/
	void delete_child(cl_base*);
	//-----------------
/*получения указателя на объект по координате на дереве объектов*/
	cl_base* get_from_tree(int);


	/*установки связи между сигналом и обработчиком*/
	void set_signal(/*???*/);
	/*удаления связи между сигналом и обработчиком*/
	void delete_signal(/*???*/);
	/*выдачи сигнала и передачи текстового сообщения*/
	/*Особо обратить внимание на реализацию сигналов и обработчиков. При выдаче сигнала (вызове метода emit_signal) в качестве аргументов передаются указатель на метод сигнала и строковая переменна содержащая определенное сообщение. По реализованному алгоритму метод сигнала вызывается один раз и по одному разу все обработчики, связанные с данным сигналом. Строковая переменная методу сигнала передается по ссылке и его содержимое может быть отредактировано алгоритмом реализации метода сигнала. Та-же строковая переменная обработчикам передается по значению. Так обеспечивается передача одинакового сообщения всем обработчикам при выдаче сигнала.*/
	void emit_signal(void*, std::string);

};






#endif